<?xml version="1.0" encoding="utf-8"?>
<mscript xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <version>9.12</version>
   <release>2022a</release>
   <date>2023-03-01</date>
   <cell style="overview">
      <count>1</count>
      <steptitle style="document">BattMo Tutorial</steptitle>
      <text>
         <p>This tutorial explains how to setup and run a simulation in BattMo</p>
      </text>
   </cell>
   <cell>
      <count>2</count>
      <steptitle>Setting up the environment</steptitle>
      <text>
         <p>BattMo uses functionality from `MRST <a href="MRSTBattMo">MRSTBattMo</a>`. This functionality is collected into modules where each module contains code for doing specific things. To use this functionality we must add these modules to the matlab path by running:</p>
      </text>
      <mcode>mrstModule add ad-core mrst-gui mpfa agmg linearsolvers</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">mrstModule <mwsh:strings xml:space="preserve">add</mwsh:strings> <mwsh:strings xml:space="preserve">ad-core</mwsh:strings> <mwsh:strings xml:space="preserve">mrst-gui</mwsh:strings> <mwsh:strings xml:space="preserve">mpfa</mwsh:strings> <mwsh:strings xml:space="preserve">agmg</mwsh:strings> <mwsh:strings xml:space="preserve">linearsolvers</mwsh:strings></mwsh:code>
      </mcode-xmlized>
      <mcode-count>1</mcode-count>
   </cell>
   <cell>
      <count>3</count>
      <steptitle>Specifying the physical model</steptitle>
      <text>
         <p>In this tutorial we will simulate a lithium-ion battery consisting of a negative electrode, a positive electrode and an electrolyte. <b>BattMo</b> comes with some pre-defined models which can be loaded from JSON files. Here we will load the basic lithium-ion model JSON file which comes with Battmo.</p>
      </text>
      <mcode>fname = fullfile('ParameterData','BatteryCellParameters',...
    'LithiumIonBatteryCell','lithium_ion_battery_nmc_graphite.json');
jsonstruct = parseBattmoJson(fname);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">fname = fullfile(<mwsh:strings xml:space="preserve">'ParameterData'</mwsh:strings>,<mwsh:strings xml:space="preserve">'BatteryCellParameters'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
    <mwsh:strings xml:space="preserve">'LithiumIonBatteryCell'</mwsh:strings>,<mwsh:strings xml:space="preserve">'lithium_ion_battery_nmc_graphite.json'</mwsh:strings>);
jsonstruct = parseBattmoJson(fname);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>2</mcode-count>
   </cell>
   <cell>
      <count>4</count>
      <text>
         <p>The parseBattmoJson function parses the JSON input and creates a matlab structure containing the same fields as the JSON input. This structure can be changed to setup the model in the way that we want.</p>
      </text>
   </cell>
   <cell>
      <count>5</count>
      <text>
         <p>In this instance we will exclude temperature effects by setting use_thermal to false.</p>
      </text>
      <mcode>jsonstruct.use_thermal = false;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">jsonstruct.use_thermal = false;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>3</mcode-count>
   </cell>
   <cell>
      <count>6</count>
      <text>
         <p>We will also not use current collectors in this example:</p>
      </text>
      <mcode>jsonstruct.include_current_collectors = false;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">jsonstruct.include_current_collectors = false;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>4</mcode-count>
   </cell>
   <cell>
      <count>7</count>
      <text>
         <p>Our model will simulate diffusion so we set use_particle_diffusion to true:</p>
      </text>
      <mcode>jsonstruct.use_particle_diffusion = true;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">jsonstruct.use_particle_diffusion = true;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>5</mcode-count>
   </cell>
   <cell>
      <count>8</count>
      <text>
         <p>The structure created in the jsonstruct follows the same hierarchy as the fields in the JSON input file. These can be referenced by name in the jsonstruct. To make life easier for ourselves we define some shorthand names for various parts of the structure.</p>
      </text>
      <mcode>ne      = 'NegativeElectrode';
pe      = 'PositiveElectrode';
elyte   = 'Electrolyte';
thermal = 'ThermalModel';
am      = 'ActiveMaterial';
itf     = 'Interface';
sd      = 'SolidDiffusion';
ctrl    = 'Control';
cc      = 'CurrentCollector';</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">ne      = <mwsh:strings xml:space="preserve">'NegativeElectrode'</mwsh:strings>;
pe      = <mwsh:strings xml:space="preserve">'PositiveElectrode'</mwsh:strings>;
elyte   = <mwsh:strings xml:space="preserve">'Electrolyte'</mwsh:strings>;
thermal = <mwsh:strings xml:space="preserve">'ThermalModel'</mwsh:strings>;
am      = <mwsh:strings xml:space="preserve">'ActiveMaterial'</mwsh:strings>;
itf     = <mwsh:strings xml:space="preserve">'Interface'</mwsh:strings>;
sd      = <mwsh:strings xml:space="preserve">'SolidDiffusion'</mwsh:strings>;
ctrl    = <mwsh:strings xml:space="preserve">'Control'</mwsh:strings>;
cc      = <mwsh:strings xml:space="preserve">'CurrentCollector'</mwsh:strings>;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>6</mcode-count>
   </cell>
   <cell>
      <count>9</count>
      <text>
         <p>Now we can set the diffusion model type for the active material (am) in the positive (pe) and negative (ne) electrodes to 'full'.</p>
      </text>
      <mcode>jsonstruct.(pe).(am).diffusionModelType = 'full';
jsonstruct.(ne).(am).diffusionModelType = 'full';</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">jsonstruct.(pe).(am).diffusionModelType = <mwsh:strings xml:space="preserve">'full'</mwsh:strings>;
jsonstruct.(ne).(am).diffusionModelType = <mwsh:strings xml:space="preserve">'full'</mwsh:strings>;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>7</mcode-count>
   </cell>
   <cell>
      <count>10</count>
      <text>
         <p>To see which other types of diffusion model are available one can view <a href="Electrochemistry.ActiveMaterialInputParams">Electrochemistry.ActiveMaterialInputParams</a>.</p>
      </text>
   </cell>
   <cell>
      <count>11</count>
      <text>
         <p>When running a simulation, <b>BattMo</b> requires that all model parameters are stored in an instance of :class:`BatteryInputParams <a href="Battery.BatteryInputParams">Battery.BatteryInputParams</a>`. This class is used to initialize the simulation and is accessed by various parts of the simulator during the simulation. This class is instantiated using the jsonstruct we just created:</p>
      </text>
      <mcode>paramobj = BatteryInputParams(jsonstruct);
paramobj = paramobj.validateInputParams();</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">paramobj = BatteryInputParams(jsonstruct);
paramobj = paramobj.validateInputParams();</mwsh:code>
      </mcode-xmlized>
      <mcode-count>8</mcode-count>
   </cell>
   <cell>
      <count>12</count>
      <text>
         <p>It is also possible to update the properties of this paramobj in a similar way to updating the jsonstruct. Here we set some more parameters for the diffusion model. The definitions for these are found in the corresponding classes: :class:`ActiveMaterialInputParams <a href="Electrochemistry.ActiveMaterialInputParams">Electrochemistry.ActiveMaterialInputParams</a>` and :class:`FullSolidDiffusionModelInputParams <a href="Electrochemistry.FullSolidDiffusionModelInputParams">Electrochemistry.FullSolidDiffusionModelInputParams</a>`.</p>
      </text>
      <mcode>paramobj.(ne).(am).InterDiffusionCoefficient = 0;
paramobj.(pe).(am).InterDiffusionCoefficient = 0;

paramobj.(ne).(am).(sd).N = 5;
paramobj.(pe).(am).(sd).N = 5;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">paramobj.(ne).(am).InterDiffusionCoefficient = 0;
paramobj.(pe).(am).InterDiffusionCoefficient = 0;

paramobj.(ne).(am).(sd).N = 5;
paramobj.(pe).(am).(sd).N = 5;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>9</mcode-count>
   </cell>
   <cell>
      <count>13</count>
      <steptitle>Setting up the geometry</steptitle>
      <text>
         <p>Here, we setup the 1D computational mesh that will be used for the simulation. The required discretization parameters are already included in the class BatteryGenerator1D. Classes for generating other geometries can be found in the BattMo/Battery/BatteryGeometry folder.</p>
      </text>
      <mcode>gen = BatteryGenerator1D();</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">gen = BatteryGenerator1D();</mwsh:code>
      </mcode-xmlized>
      <mcode-count>10</mcode-count>
   </cell>
   <cell>
      <count>14</count>
      <text>
         <p>Now, we update the paramobj with the properties of the mesh. This function will update relevent parameters in the paramobj object and make sure we have all the required parameters for the model geometry chosen.</p>
      </text>
      <mcode>paramobj = gen.updateBatteryInputParams(paramobj);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">paramobj = gen.updateBatteryInputParams(paramobj);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>11</mcode-count>
   </cell>
   <cell>
      <count>15</count>
      <steptitle>Initialising the battery model object</steptitle>
      <text>
         <p>The battery model is initialized by sending paramobj to the Battery class constructor. see :class:`Battery <a href="Battery.Battery">Battery.Battery</a>`.</p>
      </text>
      <mcode>model = Battery(paramobj);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">model = Battery(paramobj);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>12</mcode-count>
   </cell>
   <cell>
      <count>16</count>
      <text>
         <p>In BattMo a battery model is actually a collection of submodels: Electrolyte, Negative Electrode, Positive Electrode, Thermal Model and Control Model. The battery class contains all of these submodels and various other parameters necessary to run the simulation. To see what properties the battery model object has we can print out the model variable:</p>
      </text>
      <mcode>model</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">model</mwsh:code>
      </mcode-xmlized>
      <mcode-count>13</mcode-count>
   </cell>
   <cell>
      <count>17</count>
      <steptitle>Controlling the simulation</steptitle>
      <text>
         <p>The control model specifies how the simulation is controlled. This can also be thought of as the boundary conditions of the simulation. In the first instance we use IEswitch control policy. (NOTE WHAT IS IESWITCH?) We set the total time scaled by the CRate in the model. The CRate has been set by the json file. We can access it here:</p>
      </text>
      <mcode>CRate = model.Control.CRate;
total = 1.4*hour/CRate;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">CRate = model.Control.CRate;
total = 1.4*hour/CRate;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>14</mcode-count>
   </cell>
   <cell>
      <count>18</count>
      <text>
         <p>We want to break this total time into 100 timesteps. To begin with we will use equal values for each timestep.</p>
      </text>
   </cell>
   <cell>
      <count>19</count>
      <text>
         <p>We create a structure containing the length of each step in seconds ('val') and also which control to use for each step ('control').</p>
      </text>
   </cell>
   <cell>
      <count>20</count>
      <text>
         <p>In this case we use control 1 for all steps. This means that the functions used to setup the control values are the same at each step.</p>
      </text>
      <mcode>n  = 100;
dt = total/n;
step = struct('val', dt*ones(n, 1), 'control', ones(n, 1));</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">n  = 100;
dt = total/n;
step = struct(<mwsh:strings xml:space="preserve">'val'</mwsh:strings>, dt*ones(n, 1), <mwsh:strings xml:space="preserve">'control'</mwsh:strings>, ones(n, 1));</mwsh:code>
      </mcode-xmlized>
      <mcode-count>15</mcode-count>
   </cell>
   <cell>
      <count>21</count>
      <text>
         <p>For the IESwitch control we will switch between controlling the current or the voltage based on some max and min values. We do this using the rampupSwitchControl function.</p>
      </text>
   </cell>
   <cell>
      <count>22</count>
      <text>
         <p>Smaller time steps are used to ramp up the current from zero to its operational value. Larger time steps are then used for the normal operation.</p>
      </text>
   </cell>
   <cell>
      <count>23</count>
      <text>
         <p>This function also contains the logic about when to switch using constant current to constant voltage.</p>
      </text>
   </cell>
   <cell>
      <count>24</count>
      <text>
         <p>First we set a parameter to control how the current values increase between zero and the desired value. Then we assign the rampupSwitchControl function to a variable as an anonymous function.</p>
      </text>
      <mcode>tup = 0.1;
srcfunc = @(time, I, E) rampupSwitchControl(time, tup, I, E, ...
                                            model.Control.Imax, ...
                                            model.Control.lowerCutoffVoltage);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">tup = 0.1;
srcfunc = @(time, I, E) rampupSwitchControl(time, tup, I, E, <mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                            model.Control.Imax, <mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                            model.Control.lowerCutoffVoltage);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>16</mcode-count>
   </cell>
   <cell>
      <count>25</count>
      <text>
         <p>We create a control structure containing the source function and specifying that we want to use IESwitch control:</p>
      </text>
      <mcode>control = struct('src', srcfunc, 'IEswitch', true);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">control = struct(<mwsh:strings xml:space="preserve">'src'</mwsh:strings>, srcfunc, <mwsh:strings xml:space="preserve">'IEswitch'</mwsh:strings>, true);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>17</mcode-count>
   </cell>
   <cell>
      <count>26</count>
      <text>
         <p>Finally we collect the control and step structures together in a schedule struct which is the schedule which the simulation will follow:</p>
      </text>
      <mcode>schedule = struct('control', control, 'step', step);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">schedule = struct(<mwsh:strings xml:space="preserve">'control'</mwsh:strings>, control, <mwsh:strings xml:space="preserve">'step'</mwsh:strings>, step);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>18</mcode-count>
   </cell>
   <cell>
      <count>27</count>
      <steptitle>Setting the initial state of the battery</steptitle>
      <text>
         <p>To run simulation we need to know the starting point which we will run it from, in terms of the value of the primary variables being modelled at the start of the simulation. The initial state of the model is setup using the model.setupInitialState() method. WHAT IS HAPPENING HERE? WHAT ARE THE INITIAL VALUES SET TO?</p>
      </text>
      <mcode>initstate = model.setupInitialState();</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">initstate = model.setupInitialState();</mwsh:code>
      </mcode-xmlized>
      <mcode-count>19</mcode-count>
   </cell>
   <cell>
      <count>28</count>
      <steptitle>Running the simulation</steptitle>
      <text>
         <p>Once we have the initial state, the model and the schedule, we can call the simulateScheduleAD function which will actually run the simulation:</p>
      </text>
      <mcode>[wellSols, states, report] = simulateScheduleAD(initstate, model, schedule);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">[wellSols, states, report] = simulateScheduleAD(initstate, model, schedule);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>20</mcode-count>
   </cell>
   <cell>
      <count>29</count>
      <text>
         <p>The outputs from the simulation are: - wellSols: which provides the current and voltage of the battery at each timestep. (This naming convention is a hangover from MRST where we model reservoir injection via injection wells). - states: which contains the values of the primary variables in the model at each timestep. - reports: which contains technical information about the steps used in the numerical solvers.</p>
      </text>
   </cell>
   <cell>
      <count>30</count>
      <steptitle>Plotting the results</steptitle>
      <text>
         <p>To get the results we use the matlab cellfun function to extract the values Control.E, Control.I and time from each timestep (cell in the cell array) in states. We can then plot the vectors.</p>
      </text>
      <mcode>E = cellfun(@(x) x.Control.E, states);
I = cellfun(@(x) x.Control.I, states);
time = cellfun(@(x) x.time, states);

figure()
subplot(1,2,1)
plot(time/hour, E)
xlabel('time [hours]')
ylabel('Cell Voltage [V]')

subplot(1,2,2)
plot(time/hour, I)
xlabel('time [hours]')
ylabel('Cell Current [A]')


%{
Copyright 2021-2022 SINTEF Industry, Sustainable Energy Technology
and SINTEF Digital, Mathematics &amp; Cybernetics.

This file is part of The Battery Modeling Toolbox BattMo

BattMo is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BattMo is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BattMo.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
%}</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">E = cellfun(@(x) x.Control.E, states);
I = cellfun(@(x) x.Control.I, states);
time = cellfun(@(x) x.time, states);

figure()
subplot(1,2,1)
plot(time/hour, E)
xlabel(<mwsh:strings xml:space="preserve">'time [hours]'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Cell Voltage [V]'</mwsh:strings>)

subplot(1,2,2)
plot(time/hour, I)
xlabel(<mwsh:strings xml:space="preserve">'time [hours]'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Cell Current [A]'</mwsh:strings>)


<mwsh:comments xml:space="preserve">%{
</mwsh:comments><mwsh:comments xml:space="preserve">Copyright 2021-2022 SINTEF Industry, Sustainable Energy Technology
</mwsh:comments><mwsh:comments xml:space="preserve">and SINTEF Digital, Mathematics &amp; Cybernetics.
</mwsh:comments><mwsh:comments xml:space="preserve">
</mwsh:comments><mwsh:comments xml:space="preserve">This file is part of The Battery Modeling Toolbox BattMo
</mwsh:comments><mwsh:comments xml:space="preserve">
</mwsh:comments><mwsh:comments xml:space="preserve">BattMo is free software: you can redistribute it and/or modify
</mwsh:comments><mwsh:comments xml:space="preserve">it under the terms of the GNU General Public License as published by
</mwsh:comments><mwsh:comments xml:space="preserve">the Free Software Foundation, either version 3 of the License, or
</mwsh:comments><mwsh:comments xml:space="preserve">(at your option) any later version.
</mwsh:comments><mwsh:comments xml:space="preserve">
</mwsh:comments><mwsh:comments xml:space="preserve">BattMo is distributed in the hope that it will be useful,
</mwsh:comments><mwsh:comments xml:space="preserve">but WITHOUT ANY WARRANTY; without even the implied warranty of
</mwsh:comments><mwsh:comments xml:space="preserve">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</mwsh:comments><mwsh:comments xml:space="preserve">GNU General Public License for more details.
</mwsh:comments><mwsh:comments xml:space="preserve">
</mwsh:comments><mwsh:comments xml:space="preserve">You should have received a copy of the GNU General Public License
</mwsh:comments><mwsh:comments xml:space="preserve">along with BattMo.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</mwsh:comments><mwsh:comments xml:space="preserve">%}</mwsh:comments></mwsh:code>
      </mcode-xmlized>
      <mcode-count>21</mcode-count>
      <cellOutputTarget>1</cellOutputTarget>
      <mcodeoutput class="codeoutput">
model = 

  Battery with properties:

                           con: [1×1 PhysicalConstants]
                   Electrolyte: [1×1 Electrolyte]
             NegativeElectrode: [1×1 Electrode]
...</mcodeoutput>
      <img src="battMoTutorial_01.png"/>
   </cell>
   <originalCode>%% BattMo Tutorial
% This tutorial explains how to setup and run a simulation in BattMo

%%% Setting up the environment
% BattMo uses functionality from `MRST &lt;MRSTBattMo&gt;`. This functionality 
% is collected into modules where each module contains code for doing 
% specific things. To use this functionality we must add these modules to 
% the matlab path by running:

mrstModule add ad-core mrst-gui mpfa agmg linearsolvers

%%% Specifying the physical model
% In this tutorial we will simulate a lithium-ion battery consisting of a 
% negative electrode, a positive electrode and an electrolyte. *BattMo* 
% comes with some pre-defined models which can be loaded from JSON files.
% Here we will load the basic lithium-ion model JSON file which comes with
% Battmo.

fname = fullfile('ParameterData','BatteryCellParameters',...
    'LithiumIonBatteryCell','lithium_ion_battery_nmc_graphite.json');
jsonstruct = parseBattmoJson(fname);

%%%
% The parseBattmoJson function parses the JSON input and creates a matlab
% structure containing the same fields as the JSON input. This structure 
% can be changed to setup the model in the way that we want. 

%%%
% In this instance we will exclude temperature effects by setting
% use_thermal to false.

jsonstruct.use_thermal = false;

%%%
% We will also not use current collectors in this example:

jsonstruct.include_current_collectors = false;

%%%
% Our model will simulate diffusion so we set use_particle_diffusion to
% true:

jsonstruct.use_particle_diffusion = true;

%%%
% The structure created in the jsonstruct follows the same hierarchy as the
% fields in the JSON input file. These can be referenced by name in the
% jsonstruct. To make life easier for ourselves we define some shorthand
% names for various parts of the structure.

ne      = 'NegativeElectrode';
pe      = 'PositiveElectrode';
elyte   = 'Electrolyte';
thermal = 'ThermalModel';
am      = 'ActiveMaterial';
itf     = 'Interface';
sd      = 'SolidDiffusion';
ctrl    = 'Control';
cc      = 'CurrentCollector';

%%%
% Now we can set the diffusion model type for the active material (am) in the
% positive (pe) and negative (ne) electrodes to 'full'.

jsonstruct.(pe).(am).diffusionModelType = 'full';
jsonstruct.(ne).(am).diffusionModelType = 'full';

%%%
% To see which other types of diffusion model are available one can view 
% &lt;Electrochemistry.ActiveMaterialInputParams&gt;.

%%%
% When running a simulation, *BattMo* requires that all model parameters
% are stored in an instance of :class:`BatteryInputParams &lt;Battery.BatteryInputParams&gt;`. 
% This class is used to initialize the simulation and is accessed by
% various parts of the simulator during the simulation. This class is
% instantiated using the jsonstruct we just created:

paramobj = BatteryInputParams(jsonstruct);
paramobj = paramobj.validateInputParams();

%%%
% It is also possible to update the properties of this paramobj in a
% similar way to updating the jsonstruct. Here we set some more parameters
% for the diffusion model. The definitions for these are found in the 
% corresponding classes:
% :class:`ActiveMaterialInputParams &lt;Electrochemistry.ActiveMaterialInputParams&gt;`
% and :class:`FullSolidDiffusionModelInputParams &lt;Electrochemistry.FullSolidDiffusionModelInputParams&gt;`.

paramobj.(ne).(am).InterDiffusionCoefficient = 0;
paramobj.(pe).(am).InterDiffusionCoefficient = 0;

paramobj.(ne).(am).(sd).N = 5;
paramobj.(pe).(am).(sd).N = 5;

%%% Setting up the geometry
% Here, we setup the 1D computational mesh that will be used for the
% simulation. The required discretization parameters are already included
% in the class BatteryGenerator1D. Classes for generating other geometries can
% be found in the BattMo/Battery/BatteryGeometry folder.

gen = BatteryGenerator1D();

%%%
% Now, we update the paramobj with the properties of the mesh. This function
% will update relevent parameters in the paramobj object and make sure we have
% all the required parameters for the model geometry chosen.

paramobj = gen.updateBatteryInputParams(paramobj);

%%% Initialising the battery model object
% The battery model is initialized by sending paramobj to the Battery class
% constructor. see :class:`Battery &lt;Battery.Battery&gt;`.

model = Battery(paramobj);

%%%
% In BattMo a battery model is actually a collection of submodels: 
% Electrolyte, Negative Electrode, Positive Electrode, Thermal Model and Control
% Model. The battery class contains all of these submodels and various other 
% parameters necessary to run the simulation.
% To see what properties the battery model object has we can print out the model 
% variable:

model

%%% Controlling the simulation
% The control model specifies how the simulation is controlled. This can
% also be thought of as the boundary conditions of the simulation.
% In the first instance we use IEswitch control policy. (NOTE WHAT IS IESWITCH?)
% We set the total time scaled by the CRate in the model.
% The CRate has been set by the json file. We can access it here:

CRate = model.Control.CRate;
total = 1.4*hour/CRate;

%%%
% We want to break this total time into 100 timesteps. To begin with we
% will use equal values for each timestep. 

%%%
% We create a structure containing the length of each step in seconds 
% ('val') and also which control to use for each step ('control'). 

%%%
% In this case we use control 1 for all steps. This means that the functions 
% used to setup the control values are the same at each step.

n  = 100;
dt = total/n;
step = struct('val', dt*ones(n, 1), 'control', ones(n, 1));

%%%
% For the IESwitch control we will switch between controlling the current
% or the voltage based on some max and min values. We do this using the
% rampupSwitchControl function. 

%%%
% Smaller time steps are used to ramp up the current from zero to its
% operational value. Larger time steps are then used for the normal
% operation. 

%%%
% This function also contains the logic about when to switch
% using constant current to constant voltage.

%%%
% First we set a parameter to control how the current values increase
% between zero and the desired value. Then we assign the
% rampupSwitchControl function to a variable as an anonymous function.

tup = 0.1; 
srcfunc = @(time, I, E) rampupSwitchControl(time, tup, I, E, ...
                                            model.Control.Imax, ...
                                            model.Control.lowerCutoffVoltage);

%%%
% We create a control structure containing the source function and
% specifying that we want to use IESwitch control:

control = struct('src', srcfunc, 'IEswitch', true);

%%%
% Finally we collect the control and step structures together in a schedule
% struct which is the schedule which the simulation will follow:

schedule = struct('control', control, 'step', step); 


%%% Setting the initial state of the battery
% To run simulation we need to know the starting point which we will run it
% from, in terms of the value of the primary variables being modelled at
% the start of the simulation. 
% The initial state of the model is setup using the model.setupInitialState()
% method. WHAT IS HAPPENING HERE? WHAT ARE THE INITIAL VALUES SET TO?

initstate = model.setupInitialState(); 


%%% Running the simulation
% Once we have the initial state, the model and the schedule, we can call
% the simulateScheduleAD function which will actually run the simulation:
[wellSols, states, report] = simulateScheduleAD(initstate, model, schedule); 

%%%
% The outputs from the simulation are:
% - wellSols: which provides the current and voltage of the battery at each 
% timestep. (This naming convention is a hangover from MRST where we model
% reservoir injection via injection wells).
% - states: which contains the values of the primary variables in the model
% at each timestep.
% - reports: which contains technical information about the steps used in
% the numerical solvers.


%%% Plotting the results
% To get the results we use the matlab cellfun function to extract the
% values Control.E, Control.I and time from each timestep (cell in the cell
% array) in states. We can then plot the vectors.

E = cellfun(@(x) x.Control.E, states); 
I = cellfun(@(x) x.Control.I, states);
time = cellfun(@(x) x.time, states); 

figure()
subplot(1,2,1)
plot(time/hour, E)
xlabel('time [hours]')
ylabel('Cell Voltage [V]')

subplot(1,2,2)
plot(time/hour, I)
xlabel('time [hours]')
ylabel('Cell Current [A]')


%{
Copyright 2021-2022 SINTEF Industry, Sustainable Energy Technology
and SINTEF Digital, Mathematics &amp; Cybernetics.

This file is part of The Battery Modeling Toolbox BattMo

BattMo is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BattMo is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BattMo.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
%}












</originalCode>
   <m-file>battMoTutorial</m-file>
   <filename>/home/francesca/battmo-github/BattMo-dev/Examples/battMoTutorial.m</filename>
   <outputdir>/home/francesca/battmo-github/BattMo-dev/Documentation/utils/../../Examples/../Documentation/publishedExamples</outputdir>
</mscript>