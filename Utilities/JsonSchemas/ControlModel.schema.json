{
  "$id": "file://./ControlModel.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties" : {
    "Control" : {
      "type" : "object",
      "properties" : {
        "controlPolicy": {
          "type": "string",
          "enum": ["CCDischarge",
                   "CCCharge",
                   "CC",
                   "CCCV",
                   "powerControl",
		           "timeControl"]}}
    }},
    "allOf": [
      {"if": {
        "properties": {"controlPolicy" : {"const" : "CCDischarge"}},
        "then": {
          "$ref" : "#/$defs/CCDischarge"}}},
      {"if": {
        "properties": {"controlPolicy" : {"const" : "CCCharge"}},
        "then": {
          "$ref" : "#/$defs/CCCharge"}}},
      {"if": {
        "properties": {"controlPolicy" : {"const" : "CCCV"}},
        "then":{
          "$ref" : "#/$defs/CCCV"}}},
      {"if": {
        "properties": {"controlPolicy" : {"const" : "CCCV"}},
        "then":{
          "$ref" : "#/$defs/timeControl"}}},
      {"if": {
        "properties": {"controlPolicy" : {"const" : "powerControl"}},
        "then": {
          "$ref" : "#/$defs/powerControl"}}}
    ],

  "$defs" : {
    "CCDischarge" : {
      "properties" : {
        "DRate" : {
          "type" : "number",
          "description" : "discharge rate"},
        "rampupTime" : {
          "type" : "number",
          "description" : "Rampup time where the current is increased linearly from zero to target value. In this way, we can avoid convergence issues in case of high current. Default value is zero, which means no rampup time"},
        "lowerCutoffVoltage" : {
          "type" : "number"},
        "useCVswitch" : {
          "type" : "boolean",
          "description" : "Switch to control voltage when the lower cutoff voltage is reached. Default value is false, which means that the simulation stops when the lower voltage is reached."
        }}},
    "CCCharge" : {
      "properties" : {
        "CRate" : {
          "type" : "number",
          "description" : "charge rate"},
        "rampupTime" : {
        "type" : "number",
        "description" : "Rampup time where the current is increased linearly from zero to target value. In this way, we can avoid convergence issues in case of high current."},
       "upperCutoffVoltage" : {
         "type" : "number"},
       "useCVswitch" : {
         "type" : "boolean",
         "description" : "Switch to control voltage when the upper cutoff voltage is reached. Default value is true."
       }
      }
    },
    "CCCV": {
      "properties" : {
        "CRate" : {
          "type" : "number",
          "description" : "charge rate"},
        "DRate" : {
          "type" : "number",
          "description" : "discharge rate"},
        "lowerCutoffVoltage" : {
          "type" : "number"},
        "upperCutoffVoltage" : {
	  "type" : "number"},
        "dEdtLimit" : {"type" : "number"},
        "dIdtLimit" : {"type" : "number"},
        "numberOfCycles" : {"type" : "number"},
        "initialControl" : {"type" : "string",
                            "enum" : ["discharging", "charging"]},
        "switchTolerances" : {
          "type" : "object",
          "description" : "tolerances for the computation of the control switching (relative tolerances)",
          "properties" : {
            "CC_discharge1" : { "type" : "number",
                                "description" : "control corresponding to constant current discharge until lower cutoff voltage is reached, default value : 1e-2"},
            "CC_discharge2" : { "type" : "number",
                                "description" :  "control corresponding to zero current until dEdtLimit is reached. Default value : 0.9"},
            "CC_charge1" : { "type" : "number",
                             "description" :  "control corresponding to constant current charge until upper cutoff voltage is reached. Default value : 1e-2"},
            "CV_charge2" : { "type" : "number",
                             "description" :  "control corresponding to constant voltage until dIdtLimit is reached. Default value : 0.9"}
          }
        }
      }},

    "powerControl": {
      "properties" : {
        "case" : {"type" : "string",
                  "enum" : ["time limited", "voltage limited", "CPCV"]},
        "dischargingPower" : {"type" : "number"},
        "chargingPower" : {"type" : "number"}},

      "anyOf" : [
        { "properties" : {
          "powerControlCase" : {"const" : "time limited"},
          "dischargingTime" : {"type" : "number"},
          "chargingTime" : {"type" : "number"}
        }},

        { "properties" : {
          "powerControlCase" : {"const" : "voltage limited"}
        }},

        { "properties" : {
          "powerControlCase" : {"const" : "CPCV"},
          "lowerCutoffPower" : {"type" : "number"},
          "upperCutoffPower" : {"type" : "number"}
        }
        }
      ]},
    "timeControl" : {
      "properties" : {
        "inputype" : {
          "type" : "string",
          "enum" : ["table", "function"],
          "description" : "If inputtype is table, The time dependent control will be given using tables, using the values key and either the times or the durations key. If inputtype is function, the time dependent control will be given using a function given by the function key. To define the function, we use the function interface"
        },        
        "times" : {
          "type" : "array",
          "items" : {"type" : "number"},
          "description" : "Array of increasing time value (wall clock). We do not include the initial time (assumed to be zero). For each time interval, the value given by the value key and the control type key is applied"
        },
        "times" : {
          "type" : "array",
          "items" : {"type" : "number"},
          "description" : "Array of durations corresponding to successive time intervals. For each interval, the value given by the value key and the control type key is applied"
        },
        "values" : {
          "type" : "array",
          "items" : {"type" : "number"},
          "description" : "Value for the control at each interval. The value is either an applied current or voltage, depending on"
        },
        "controltypes" : {
          "type" : "array",
          "items" : {"type" : "number"},
          "description" : "Control type for each interval. It can be either current, then we set the control type value to 1, or voltage, then we set the control type value to 2."
 
        },        
        "controlValueFunction" : {
          "$ref": "Function.schema.json",
          "description" : "function of time that returns the value for the control"
        },
        "controlTypeFunction" : {
          "$ref": "Function.schema.json",
          "description" : "function of time that returns the value for the type control, where 1 corresponds to current control and 2 corresponds to voltage control"
        }
      }

    }
  }
}
